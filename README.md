# CS330

The goal of this project was to replicate a 2D reference image in a 3D environment using OpenGL and C++. For my final scene, I chose to replicate the visual simplicity and educational symbolism of children's building blocks commonly found in classrooms. These blocks were represented through a stack of four geometric primitives—box, cylinder, sphere, and cone—arranged vertically to mimic the way children build and explore physical space. This design allowed me to demonstrate not only geometric modeling and texturing, but also realistic lighting and interactive camera control.
To create the stacked block tower, I used a box as the foundational base. Above it, I placed a cylinder, then a sphere, and finally a cone at the top. Each shape was modeled with a low polygon count to stay within the requirement of fewer than 1,000 triangles per object. The combination of these simple primitives created a visually cohesive structure while keeping the geometry efficient. The models were chosen not only for their simplicity but also because they represent fundamental learning tools, reinforcing the educational theme of the scene. Scaling and translation transformations were used to ensure the stack looked proportionally balanced and vertically aligned along the Y-axis.
For texturing, I applied a brick texture to the box and a marble texture to the sphere, both of which were sourced from royalty-free libraries such as ambientCG (ambientCG, n.d.). These textures were chosen to evoke the feel of classroom materials—solid, textured surfaces that children might interact with. The use of high-resolution (1024×1024 or greater) textures ensured clarity and realistic surface appearance in the final render. Texture coordinates were carefully mapped using the CreateGLTexture and BindGLTextures functions to ensure proper projection without distortion. I paid attention to texture wrapping and filtering options to ensure surfaces displayed smoothly from all camera angles.
Lighting was applied using a point light positioned above and to the side of the stacked structure, along with a secondary colored directional light to add visual contrast. Both light sources utilized the Phong shading model, incorporating ambient, diffuse, and specular components (Angel & Shreiner, 2020). This lighting configuration gave the scene depth and made material textures appear more dynamic as the camera moved. The colored light was given a soft red hue to introduce warmth, emulating the inviting atmosphere of a classroom. I adjusted the shininess and specular intensity of materials to emphasize different surface qualities, with shinier materials placed higher on the stack.
Camera navigation was critical for user immersion. I implemented movement along the X, Y, and Z axes using the WASD keys for horizontal translation and the Q/E keys for vertical movement. Mouse movement was mapped to yaw and pitch, allowing the user to look around the scene, while the scroll wheel controlled the movement speed. These controls were implemented through the ProcessKeyboardEvents and ProcessMouseMovement functions to provide fine-tuned control over the viewing experience. The camera radius was carefully chosen to ensure all objects remained within the viewport and were properly lit from all angles during navigation.
A key press allowed users to toggle between perspective and orthographic views. This functionality was implemented via a conditional swap between glm::perspective and glm::ortho, offering users flexibility in how they interpret the 3D space. This was especially useful for evaluating spatial alignment between the stacked objects. Perspective view helped showcase the scene’s depth and realism, while orthographic view provided technical clarity, making it easier to evaluate alignments and object proportions in a planar format.
Throughout development, I used custom functions to enhance code clarity and reusability. Functions such as LoadSceneTextures, DefineObjectMaterials, and SetupSceneLights modularized major tasks, allowing me to isolate responsibilities like texture loading, lighting configuration, and material definition. This modular approach followed best practices by reducing redundancy and making future scene extensions more manageable (Shreiner, Sellers, Kessenich, & Licea-Kane, 2013). These modular functions not only improved organization but also simplified debugging, especially when isolating rendering issues.
Additionally, encapsulating mesh creation in classes like ShapeMeshes and calling these from the SceneManager::RenderScene method helped maintain logical separation between data and rendering logic. Commenting was added to all major function blocks, explaining their responsibilities and how parameters affect behavior, which improved readability and debugging efficiency. The codebase as a whole was structured to prioritize clarity and educational value, which aligns with the spirit of the scene being inspired by early childhood learning.
By modeling a child’s block stack with simple 3D primitives and applying real-world textures and lighting effects, I was able to effectively replicate a 2D classroom-themed image in a dynamic 3D environment. Using modular, well-commented code and thoughtful input handling, I ensured a polished and navigable scene that responds to user input and provides both technical functionality and visual appeal. This project has reinforced key OpenGL development concepts including modeling, texturing, lighting, and navigation. I am confident that these techniques will translate well to more complex graphics projects in future academic or professional settings.
